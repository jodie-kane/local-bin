#!/bin/bash

# basically an awk version of 'GNU-cut'
# but allows a multiple character field separator
# and negative ranges

min=1   # lowest record
max=-1  # highest record
len=-1  # used to calculate max=(min+len)
FS=" "  # AWK FIELD SEPARATOR; SPACE.
ofs=""  # AWK OUTPUT SEPARATOR
only="" # return only the field specified (a bit like 'cut -f')

cmd_name="$(basename ${0})"
usage="

  ${cmd_name} [-F <sep>] [-M <max>] [-l <len>] [-m <min>] [-o <only>] [file...]

"
examples="      
  EXAMPLES: 

  The following are all equivalent:

    shell> echo 'a|b|c|d|e' | ${cmd_name} -F'|' -o 3,4
    shell> echo 'a|b|c|d|e' | ${cmd_name} -F'|' -o 3-4
    shell> echo 'a|b|c|d|e' | ${cmd_name} -F'|' -m 3 -M 4
    shell> echo 'a|b|c|d|e' | ${cmd_name} -F'|' -m 3 -l 2

"

OPTIND=
while getopts 'F:M:O:hl:m:o:' flag
do
 case "${flag}" in
  F) FS="${OPTARG}";;
  M) max=${OPTARG};;
  O) ofs="-v OFS=${OPTARG}";;
  h) echo -n "${usage}${examples}"; 
     exit 0;;
  l) len=${OPTARG};;
  m) min=${OPTARG};;
  o) only=${OPTARG};;
 esac
 shift $(( OPTIND - 1 ))
 OPTIND=
done

# expect piped input from stdin or a specified file
if [[ ! -p /dev/stdin && $# -eq 0 ]]
then
  echo -n "
  Egg: We found no input! 
  ${usage}
  " >&2
  exit 1
fi

# if not specified, set OFS to FS
ofs="${ofs:--v OFS=${FS}}"

## max = min + len 
if [[ ${max} -le 0 && ${len} -ne -1 ]]
then
  max=$(( ${min} + ${len} - 1 ))
fi

## parse only for min & max
if [[ "x${only}" != "x" ]]
then

    # evaluation of each element in the 'only' spec is iterative, and changes the min/max bounds
    # therefore there is no real advantage to calculating min/max values here.
    min=1
    max='NF' 
    ao="-v only=${only}"

fi

# run awk with args ;)
awk -F"${FS}" -v "MINF=${min}" -v "MAXF=${max}" ${ao} ${ofs} '

BEGIN { 
  PROCINFO["sorted_in"] = "@ind_str_asc";

  if ( only ){ 
    # printf("only: %s\n", only );
    olen = split(only, os, ","); 
    if( olen == 0 ){
      os[1] = only
    }
  } 

  # debug=""
} 

{

  sep = OFS;
  # o-spec
  oslen = length(os);
  # printf("oslen: %d\n", oslen);
  if ( oslen > 0 ){

   for ( i=1; i<=oslen; i++ ){
    
     # calculate min/max from spec element
     n = os[i]; 

     if ( n ~ /^[0-9]+$/ ){ 
       n=strtonum(n)
       s=n; e=n; 
        # printf("i:= s:%s,e:%s\n", s, e );
     }

     if ( n ~ /-/ ){

       # extract int values from o-spec
       split( n, o, "-" );  
     
       # could perhaps merge the regex... 
       if ( n ~ /^-[0-9]+$/       ){ s=1; e=strtonum(o[2]); }
       if ( n ~ /^[0-9]+-$/       ){ s=strtonum(o[1]); e=NF;   }
       if ( n ~ /^[0-9]+-[0-9]+$/ ){ s=strtonum(o[1]); e=strtonum(o[2]); }

     }

     # printf("s:%s,e:%s\n", s, e);

     # bounds check per section
     # question? do we silently set min(e,NF)?
          
          
     # debug = sprintf("%s\n n:%s,s:%s,e:%s,sep:\"%s\"", debug, n, s, e, sep);
        # printf("s:%s,e:%s\n", s, e );

        if ( s == e ){

            if ( s > 0 || s <= NF ){ 
              if( i == oslen ){ sep = "\n"; }
              printf("%s%s", $s, sep );
            }
            
        }else{

          if( s <= e ){
             
              # silently limit upper bound to NF
              e=( e > NF ? NF : e );

              for( j=s; j<e; j++ ){
                printf("%s%s", $j, sep );            
              }

              if ( i == oslen ){ sep = "\n"; }
              printf("%s%s", $e, sep);

            }else{ 

                
                # printf("s:%s,e:%s\n", s, e);
                s=( s > NF ? NF : s )
                e=( e == 0 ? 1 : e )
                for( j=s; j>e; j-- ){
                  printf("%s%s", $j, sep );           
                }

                if( i == oslen ){ sep = "\n"; }
                printf("%s%s", $e, sep);

            }
          }
          # printf("s:%s,e:%s\n", s, e );

  }

}else{

   # from min to max, print all fields
   # check sensible bounds 
   s=MINF < 1 ? 1 : MINF

   e=MAXF; 
   if ( e < 1 || e >= NF ){ e=NF; };

   for( i=s; i<=e; i++ ){
     if( i >= MINF ){
       if( i < e ){
         printf("%s%s", $i, sep);
       }else {
         printf("%s\n", $i )
       }
     }
   }
 } 

}

END{
 # printf("debug: %s\n", debug );
}

' "${@}" 

